---
title: "DBSCAN"
author: "Bertita"
date: "2023-10-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(cluster)
library(fpc)
library(pracma)
library(factoextra)
library(dbscan)
library(gdata)
set.seed(04102022)
```

```{r, include=FALSE}
# Lectura de la base de datos
df <-get(load("C:/Users/Bertita/Downloads/Dades_post_pca.RData"))
datos <- df[, 9:16] 
```
El algoritmo DBSCAN es un método de clústering basado en densidad de aplicaciones con ruido. Este método permite agrupar los datos cuando estos presentan formas complejas, así como es un método robusto frente a la presencia de outliers. Para realizar el algoritmo DBSCAN se emplean sólo las variables numéricas normalizadas. 

DBSCAN parte de dos parámetros que son:
- Epsilon: distancia máxima a la que debe haber otra observación para ser considerar que cumple con el criterio de "estar cerca"
- Mínimo de puntos: parámetro que controla la densidad mínima requerida para que un punto sea considerado un núcleo y se incluya en un grupo/clúster.

## Cálculo de mínimo de puntos
Para calcularlo de manera empírica, diremos que el mínimo de puntos sea igual al 0.2% - 0.25% del total de los datos teniendo en cuenta que: 

  - El mínimo será de 2 para datos que sean muy pequeños
  - El máximo será de 10 para datos con mucha información

```{r, include=FALSE}
porcentaje <- 0.00225
min_pts <- round(nrow(datos) * porcentaje) 
min_pts

# Realizamos los cortes de 2 y 10 que se mencionan anteriormente como validación
min_pts <- ifelse(min_pts <= 1, 2, min_pts)
min_pts <- ifelse(min_pts >= 10, 10, min_pts)
```
Aplicando esto, se tiene que el número mínimo de puntos sería 11, pero lo limitamos a 10 en concordancia con la literatura.
 
## Cálculo de epsilon
Se escogerá epsilon a partir del siguiente gráfico del codo, realizado con el método del k-NN. Como se han realizado otros métodos de clústering, se aplica el k-NN con el valor de K sacado de los métodos de clústerng jeráriquico, que concluyen que el número de clústers k óptimo es 2. Estas k-distancias se trazan en orden ascendente con el objetivo es determinar la “codo”, que corresponde al parámetro epsilon óptimo. A partir del siguiente gráfico del codo se puede observar el valor óptimo de epsilon.

```{r}
# distanciasVecinas <- dbscan::kNNdist(datos, k = 2)
# 
# ### Ordenamos los puntos de menos a mayor y lo guardamos en un vector.
# ### Cuando realicemos el gráfico elbow, será nuestro eje de las Y
#  Y <- distanciasVecinas[order(distanciasVecinas)]
# 
# ### Calculamos el índice del eje de la X
#  X <- c(0:(length(Y) - 1))
# 
# ### A continuación calculamos las pendientes
#  pendientes <- c()
#  for (i in 1:length(X)) {
# 	pendientes[i] <- (Y[i + 1] - Y[i])/(X[i+1] - X[i])
#  }
# 
#  m <- which.max(pendientes)
# primer <- gdata::first(which(pendientes >= m))
# epsilon<- Y[m] 

kNNdistplot(datos, k = 2, minPts = min_pts)
  abline(h = 4.5, lty = 2, col = "red")

epsilon=4.5
```

El valor de epsilon se decide a aprtir de el corte en el máximo cambio de la pendiente. En el gráfico se observa que esto se da alrededor de epsilon = 5.


## Resultado DBSCAN
Aplicamos el método DBSCAN con los valores extraídos: epsilon=5346.005 y mínimo de puntos de 10. 
```{r, include=FALSE}
res <- dbscan(datos, eps = epsilon, minPts = min_pts) 
print (res)
```
EL resultado del DBSCAN indica que agrupa los datos en 2 clústers, y devuelve 64 puntos como outliers. 

Se presenta el gráfico de los clústers obtenidos con el DBSCAN:
```{r, include=FALSE}
# ### Se añade la columna clúster a mis datos.
datos$cluster <- res$cluster

### Guardo datos limpios
datos_limpios <- dplyr::filter(datos, cluster != 0)

### Guardo outliers.
outliers <- dplyr::filter(datos, cluster == 0)

### Graficamos el dbscan obtenido. Es el mismo gráfico anterior pero en PCA
fviz_cluster(object = res, data = datos, geom = "point", ellipse = FALSE,
             show.clust.cent = FALSE, pallete = "jco") +
  theme_bw() +
  theme(legend.position = "none")

```
Con estos resultados, ya se aprecia que el DBSCAN no realiza agrupaciones del todo óptimas en estos datos, ya que la inmensa mayoría de datos se ubican en el primer clúster, y el segundo clúster contiene una proporción de datos ínfima. Esto puede ser debido a que el DBSCAN es un método que parte de las densidades, y en los datos que se agrupan con formas más simples y uniformes, como los que se tratan en este trabajo, puede no encontrar la solución ótpima, como se considera en este caso. A esta misma conclusión se llegará también con el método OPTICS, ya que también es un método de clústering basado en densidades.
