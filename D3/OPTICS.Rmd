---
title: "OPTICS"
author: "Mireia Bolívar"
date: "2023-10-22"
output: html_document
---


```{r}
# Cargamos las librerias necesarias
library(cluster)
library(fpc)
library(pracma)
library(factoextra)
library(dbscan)

# =============================================================================
### Generamos una semilla para poder ejecutar los datos
set.seed(04102022)

# ==============================================================================
### Creamos la base de datos que vamos a utilizar para detectar los grupos

datos <- get(load("C:/Users/mibor/OneDrive/Documentos/GitHub/Mineria-de-dades/D3/Dades preprocessades.RData"))

### Nos quedamos únicamente con las variables numéricas

mydata <- df_preprocessed
mydata$AMT_INCOME_TOTAL <- NULL
mydata$AMT_CREDIT <- NULL
mydata$AMT_ANNUITY <- NULL
mydata$AMT_GOODS_PRICE <- NULL


rm(df_preprocessed)

Objectos <- sapply(mydata, class)
Numeriques <- names(Objectos)[which(Objectos%in%c("numeric"))]

dd <- mydata[,Numeriques]
dd<- dd[,c(2:8)]


```



# =============================================================================
# OPTICS

OPTICS (Ordering Points To Identify the Clustering Structure), es otro algoritmo de clustering utilizado en mineria de datos y análisis de datos para descubrir patrones y estructuras en conjuntos de datos; siendo su objetivo principal descubrir grupos de puntos que están densamente agrupados en el espacio de características. Fue propuesto como una mejora del algoritmo DBSCAN, dado que este tiene problemas con las fronteras. 

El algoritmo OPTICS comienza identificando los puntos centrales (core points) en el conjunto de datos (llamado `minPts`) dentro de un radio específico (llamado `eps`). Dado que una de sus limitaciones es la elección adecuada de estos parámetros, ja que son cruciales para obtener resultados óptimos, a continuación se optimiza su búsqueda:

## Búsqueda de los parámetros óptimos

**Optimizamos la búsqueda de parámetros para epsilon y minPts en Optics**

```{r}
#Cargamos las librerias necesarias:
library(doParallel) #trabaja en paralelo al coger nuestro ordenador y dividirlo en dos (bigdata)
library(foreach) #para hacer bucles
```

Primeramente, definimos los valores que se van a probar para eps y minPts, creando una cuadrícula de parámetros y, seguidamente, se establece el número de núcleos (cores) a utilizar para la optimización en paralelo, que se calcula automáticamente.
```{r}
eps_values <- seq(0.1, 1.0, by = 0.1)
minPts_values <- seq(5, 20, by = 5)

# Cuadrícula de búsqueda de los valores de eps y minPts
grid <- expand.grid(eps = eps_values, minPts = minPts_values)

### Establecemos el número de núcleos que se van a usar para realizar la optimización en paralelo
#calcula cuantos cores tenemos en nuestro ordenador, en este caso ocho
cores <- detectCores()
registerDoParallel(cores = cores)
```

**Función para ejecutar OPTICS con una combinación de parámetros y calcular el coeficiente de silueta:**

```{r}
run_optics <- function(data, eps, minPts) {
  optics <- dbscan::optics(data, eps = eps, minPts = minPts)
  res <- dbscan::extractDBSCAN(optics, eps_cl = eps)
  sil <- cluster::silhouette(res$cluster, dist(data))
  return(ifelse(is.na(sil), sil, mean(sil[, 3])))
}
### Con esta función nos permitirá luego paralelizar el proceso

### Ejecutar la cuadrícula de búsqueda en paralelo para la función dada
results <- foreach(i = 1:nrow(grid), .combine = rbind) %dopar% {
  eps <- grid$eps[i]
  minPts <- grid$minPts[i]
  score <- run_optics(dd, eps, minPts)
  c(eps, minPts, score)
} #objetivo: maximizar o minimizar el siluette.

results <- results[, c(1:3)]

### Seleccionamos la combinación de parámetros que produjo el mejor resultado
best_params <- grid[which.max(results[, 3]), ]
best_params
```
Como vemos, después del proceso iterativo, la combinación de resultados más óptima ha sido un radio (`eps`) de 0.5 con un mínimo de 5 puntos (`minPts`). 

Así mismo, a continuación creamos el modelo OPTICS con los parámetros óptimos encontrados:

```{r}
### generamos el optics maximizado
optics <- dbscan::optics(dd, eps = best_params$eps, minPts = best_params$minPts)

plot(optics, reachability=TRUE)
## Aqui debeis rescatar los resultados del cluster pero debias decidir donde cortar el reachability plot
```
<!-- no se ve na -->

**MÉTODO DE LA SILUETA**
Otra de las maneras para encontrar los valores óptimos de los parámetros necesarios es a partir del método de la silueta.

En esta sección se ejecutará OPTICS con diferentes valores de `eps`y se calcularán la medida de silueta para cada valor. Luego, se graficará esta medida en función de epsilon y se identificará su valor óptimo. 

```{r}
### Metodo de la silueta

#### Ejecutar OPTICS para diferentes valores de eps
eps_values <- seq(0.1, 1, by = 0.1)
optics_results <- lapply(eps_values, function(e) optics(dd, eps = e, minPts = 5))

#### Obtener los agrupamientos para cada valor de eps
clusters <- lapply(optics_results, function(x) extractDBSCAN(x, eps = x$eps))

#### Calcular la medida de silhouette promedio para cada valor de eps
silhouette_avg <- sapply(clusters, function(x) mean(cluster::silhouette(x$cluster, dist(dd))))

# Graficar la medida de silhouette promedio en función de eps
plot(eps_values, silhouette_avg, type = "b", pch = 20, main = "Silhouette Plot")

# Agregar una línea vertical en el valor óptimo de eps, el que maximiza la silhoutte:
opt_eps <- eps_values[which.max(silhouette_avg)]

abline(v = opt_eps, lty = 2, col = "red")
```

Como se puede apreciar, al agregar una línea vertical en el valor óptimo de epsilon, vemos que se aconseja cortar en 1, valor que maximiza la silhouette.


```{r}
# -----------------------------------------------------------------------------------
### extract a DBSCAN clustering by cutting the reachability plot at eps_cl
### La elección del eps_cl puede obtenerse segun lo explicado anteriormente
### o podeis "jugar con el obtener diferentes configuraciones de cluster como
### se hace con los dendogramas de clustering jerarquico.
opt_eps
res <- dbscan::extractDBSCAN(optics, eps_cl = opt_eps)

### black is noise
plot(res)  

### Visualizamos el gráfico con los grupos creados
dbscan::hullplot(dd, res)
res$cluster
table(res$cluster)
## No olvideis guardar los resultados del clustering como se hizo con DBSCAN
### Aqui se han formado 3 clusters, uno de ellos es NOISE o posibles OUTLIERS.
### Conviene cortar el reachability plot con otros valores diferentes de 0.10
### para obtener más clustering. Queda de EJERCICIO para CASA.
# ==============================================================================

```


## IMPORTANTE: BUSCAR
# fuzzy clustering. Cuando queremos conocer cuales son las prob de pertenecer a 
#cada uno de ellos, asi vemos si hay un individuo que pertenece a dos clusterings 
# diferentes, etc