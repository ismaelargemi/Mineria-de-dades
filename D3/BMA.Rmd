---
title: "BMA"
output: html_document
date: "`r Sys.Date()`"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r}
library(arules)
library(tidyverse)
library(knitr)
library(ggplot2)
library(lubridate)
library(plyr)
library(arulesViz)
rm(list = ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
load('dades_post_pca.Rdata')
```

Transformem les variables numèriques en categòriques aplicant la funció `discretizeDF`.

```{r}
data$CNT_FAM_MEMBERS <- (cut(data$CNT_FAM_MEMBERS, breaks = c(-Inf, 1.1,2.1,3.1,Inf), labels = c("1", "2", "3", ">=4")))
numeric <- which(sapply(data, is.numeric))

dcat <- discretizeDF(data, default = list(method = "interval", breaks = 10, include.lowest = TRUE))

levels(dcat$OWN_CAR_AGE) <-  c("Menos de 5", "[5,9]", "[10,13]", "[14,18]", "[19,22]", "[23,27]", "[28,32]", "[33,36]", "[37,41]", "Más de 42")

levels(dcat$AGE_YEARS) <- c( "Menys de 26", "[26,30]", "[31,35]", "[36,39]", "[40,44]", "[45,49]", "[50,53]", "[54,58]", "[59,63]", "Más de 62" )

# comprovació de que segueixen la mateixa distribució
# par(mfrow=c(1,2))
# for (i in numeric){
#   hist(data[,i], main = colnames(data)[i])
#   barplot(table(dcat[,i]))
# }
```

Transformem les transaccions 

```{r}
tr <- as(dcat, "transactions") # tendra tantas columnas como categorias
tr
```

```{r}
summary(tr)
```

##  Apriori 

Especifiquem els paràmetres 

```{r}
soporte_minimo <- 10/nrow(data) # Support 10/n
confianza_mínima <- 0.8 # Confiance
tamanyo_conjunto <- 10  # Tamaño máximo del conjunto
```

Creem les regles d'associació.

```{r}
reglas.asociacion <- apriori(tr, parameter = list(supp = soporte_minimo, conf = confianza_mínima, 
												  maxlen = tamanyo_conjunto)) # rhs = és la variable output
```

Dividim les nostres regles d'associació segons el consequent que és la variable resposta. La variable resposta és `TARGET` que pren valors de 1 o 0.  

```{r}
target1 <- subset(reglas.asociacion, subset = rhs%in%"TARGET=1" & lift > 1.2)
target0 <- subset(reglas.asociacion, subset = rhs%in%"TARGET=0" & lift > 1.2)
```

Treiem les regles redundants en els dos casos. 

```{r}
subconjunto.reglas <- which(colSums(is.subset(target0, target0)) > 1)
subconjunto.target0 <- target0[-subconjunto.reglas]
testFisher <- interestMeasure(subconjunto.target0, 
                              measure = "fishersExactTest",
                              transactions = tr)
summary(testFisher)

# quality(subconjunto.target0) <- cbind(quality(subconjunto.target0), testFisher)

# testFisher <- testFisher[-(which(testFisher > 0.05))]

subconjunto.target0 <- subconjunto.target0[-(which(testFisher > 0.05))]
```

```{r}
rm(subconjunto.reglas)
rm(testFisher)
subconjunto.reglas <- which(colSums(is.subset(target1, target1)) > 1)

subconjunto.target1 <- target1[-subconjunto.reglas]

testFisher <- interestMeasure(subconjunto.target1, 
                              measure = "fishersExactTest",
                              transactions = tr)
summary(testFisher)
# quality(subconjunto.target1) <- cbind(quality(subconjunto.target1), testFisher)
```

```{r, include=FALSE, echo=FALSE}
# Visualización per a target = 0 
plot(subconjunto.target0, measure = c("support", "lift"), shading = "confidence")
plot(subconjunto.target0, method = "two-key plot")
# plot(subconjunto.target0, method = "grouped") # no s'enten res
# plot(subconjunto.target0, method = "paracoord") # aquest no s'executa 
# plot(subconjunto.target0, method = "graph") # no s'entèn rés
``` 

```{r, include=FALSE, echo=FALSE}
# Visualización per a target = 1 
plot(subconjunto.target1, measure = c("support", "lift"), shading = "confidence")
plot(subconjunto.target1, method = "two-key plot")
# plot(subconjunto.target1, method = "grouped") #no s'enten res
# plot(subconjunto.target0, method = "paracoord") # aquest no s'executa 
# plot(subconjunto.target0, method = "graph") # no s'entèn rés
``` 

Con target = 0 obtenemos `r subconjunto.target0` y con tagret = 1 `r subconjunto.target1`. Vemos las 10 primeras reglas en cada caso con mayor lift. 

```{r}
subconjunto.target0<-subconjunto.target0[order(quality(subconjunto.target0)[,"lift"], decreasing = TRUE)]
top <- subconjunto.target0[1:10]
inspect(top)
```

```{r}
subconjunto.target1<-subconjunto.target1[order(quality(subconjunto.target1)[,"lift"], decreasing = TRUE)]
top <- subconjunto.target1[1:10]
inspect(top)
```

## ECLAT

En este caso creamos las reglas de asocioacion con eclat. 

```{r}
eclattr<-eclat(tr, parameter = list(support=soporte_minimo, minlen=1, maxlen=tamanyo_conjunto))

eclatTransrules<-ruleInduction(eclattr,tr,confidence=confianza_mínima)

target12 <- subset(eclatTransrules, subset = rhs%in%"TARGET=1" & lift > 1.2)
target02 <- subset(eclatTransrules, subset = rhs%in%"TARGET=0" & lift > 1.2)
summary(target02)
summary(target12)

rm(subconjunto.reglas)
subconjunto.reglas <- which(colSums(is.subset(target02, target02)) > 1)
subconjunto.target02 <- target02[-subconjunto.reglas]

rm(subconjunto.reglas)
subconjunto.reglas <- which(colSums(is.subset(target12, target12)) > 1)
subconjunto.target12 <- target12[-subconjunto.reglas]

# inspeccionem les deu regles amb major lift per a target = 0
subconjunto.target02<-subconjunto.target02[order(quality(subconjunto.target02)[,"lift"], decreasing = TRUE)]
top <- subconjunto.target02[1:10]
inspect(top)

# inspeccionem les deu regles amb major lift per a target = 1
subconjunto.target12<-subconjunto.target12[order(quality(subconjunto.target12)[,"lift"], decreasing = TRUE)]
top <- subconjunto.target12[1:10]
inspect(top)
```

